"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/builtin/interopRequireDefault");

var _react = _interopRequireDefault(require("react"));

var _enzyme = require("enzyme");

var _chai = require("chai");

var _sinon = require("sinon");

var _keycode = _interopRequireDefault(require("keycode"));

var _bindKeyboard = _interopRequireDefault(require("./bindKeyboard"));

var _ref = _react.default.createElement("div", null);

var Empty = function Empty() {
  return _ref;
};

var BindKeyboardSwipeableViews = (0, _bindKeyboard.default)(Empty);

var _ref2 = _react.default.createElement(BindKeyboardSwipeableViews, null, _react.default.createElement("div", null, 'slide n°1'), _react.default.createElement("div", null, 'slide n°2'), _react.default.createElement("div", null, 'slide n°3'));

describe('bindKeyboard', function () {
  var wrapper;
  beforeEach(function () {
    wrapper = (0, _enzyme.shallow)(_ref2);
  });
  describe('prop: children', function () {
    it('should start at the beginning', function () {
      _chai.assert.strictEqual(wrapper.state().index, 0, 'Should start at the beginning.');
    });
  });
  describe('prop: slideCount', function () {
    it('should use the slideCount to compute the index limit', function () {
      wrapper.setProps({
        slideCount: 2
      });
      wrapper.simulate('keydown', {
        keyCode: (0, _keycode.default)('right')
      });

      _chai.assert.strictEqual(wrapper.state().index, 1, 'Should increment the index.');

      wrapper.simulate('keydown', {
        keyCode: (0, _keycode.default)('right')
      });

      _chai.assert.strictEqual(wrapper.state().index, 0, 'Should go back to the beginning.');
    });
  });
  describe('keyboard strokes', function () {
    it('should increment the index', function () {
      wrapper.simulate('keydown', {
        keyCode: (0, _keycode.default)('right')
      });

      _chai.assert.strictEqual(wrapper.state().index, 1, 'Should have the right index.');
    });
    it('should decrement the index using a modulo', function () {
      wrapper.simulate('keydown', {
        keyCode: (0, _keycode.default)('left')
      });

      _chai.assert.strictEqual(wrapper.state().index, 2, 'Should have the right index.');
    });
  });
  describe('prop: onChangeIndex', function () {
    it('should be called and with the right arguments when using the keyboard', function () {
      var handleChangeIndex = (0, _sinon.spy)();
      wrapper.setProps({
        onChangeIndex: handleChangeIndex
      });
      wrapper.simulate('keydown', {
        keyCode: (0, _keycode.default)('right')
      });

      _chai.assert.strictEqual(handleChangeIndex.callCount, 1, 'Should be called the right number of time.');

      _chai.assert.deepEqual(handleChangeIndex.args, [[1, 0]]);
    });
    it('should be called with the right value when swiping', function () {
      var handleChangeIndex = (0, _sinon.spy)();
      wrapper.setProps({
        index: 0,
        onChangeIndex: handleChangeIndex
      });
      wrapper.find(Empty).simulate('changeIndex', 1, 0);

      _chai.assert.deepEqual(handleChangeIndex.args, [[1, 0]]);

      _chai.assert.strictEqual(wrapper.state().index, 0, 'should no update the state index');
    });
  });
  describe('uncontrolled', function () {
    it('should update the state index when swiping', function () {
      wrapper.setProps({});
      wrapper.find(Empty).simulate('changeIndex', 1, 0);

      _chai.assert.strictEqual(wrapper.state().index, 1, 'should update the state index');
    });
  });
});